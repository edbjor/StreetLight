/******************************************************************************
* The information contained herein is confidential property of Embraco. The
* user, copying, transfer or disclosure of such information is prohibited
* except by express written agreement with Embraco.
******************************************************************************/

/**
 * @file    crypto_module.c
 * @brief   function related to cryptography chip
 *
 * @author  Roberto Andrich
 * @date    2017-10-06
 *
 * @addtogroup CRYPTOGRAPHY
 * @{
 */


/******************************************************************************
* Include statements
******************************************************************************/
#include "std_types.h"          /* fixed-width types, max values, std return */
#include "utilities.h"          /* module header */
#include "crypto_module.h"
#include "atca_lib_return_codes.h"
#include "atca_config.h"
#include "atca_i2c.h"
#include "atca_protocol_adapter.h"
//JRF
#include "atecc508cb.h"
#include "atca_command.h"
#include "atca_basic.h"
#include "atcatls_cfg.h"
#include "aws_iot_config.h"
//#include "atca_cmds.h"
//#include "aws_kit_object.h"


/******************************************************************************
* Data types, constants and macro definitions
******************************************************************************/

enum {
	AWS_E_SUCCESS = 0,
	AWS_E_BAD_PARAM,
	AWS_E_FAILURE,
	AWS_E_NET_SOCKET_INVALID,
	AWS_E_NET_SOCKET_TIMEOUT,
	AWS_E_NET_DNS_TIMEOUT,
	AWS_E_NET_CONN_TIMEOUT,
	AWS_E_NET_CONN_FAILURE,
	AWS_E_NET_TLS_FAILURE,	
	AWS_E_NET_JITR_RETRY,
	AWS_E_WIFI_CONN_TIMEOUT,
	AWS_E_WIFI_INVALID,
	AWS_E_WIFI_CONN_FAILURE,
	AWS_E_CRYPTO_FAILURE,
	AWS_E_CRYPTO_CERT_FAILURE,
	AWS_E_CRYPTO_DATA_INVALID,
	AWS_E_USER_DATA_INVALID,
	AWS_E_CLI_PUB_FAILURE,
	AWS_E_CLI_SUB_FAILURE,
	AWS_E_MQTT_REINITIALIZE,
} AWS_KIT_RET;  


/******************************************************************************
* Static data declarations
******************************************************************************/
t_aws_kit awsKit;

//! The root CA certificate of AWS IoT server.
const uint8_t AWS_IOT_ROOT_CERT[] = {
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x43, 0x45, 0x52, 0x54, 0x49, 
	0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0D, 0x0A, 0x4D, 0x49, 0x49, 
	0x45, 0x30, 0x7A, 0x43, 0x43, 0x41, 0x37, 0x75, 0x67, 0x41, 0x77, 0x49, 0x42, 0x41, 0x67, 0x49, 
	0x51, 0x47, 0x4E, 0x72, 0x52, 0x6E, 0x69, 0x5A, 0x39, 0x36, 0x4C, 0x74, 0x4B, 0x49, 0x56, 0x6A, 
	0x4E, 0x7A, 0x47, 0x73, 0x37, 0x53, 0x6A, 0x41, 0x4E, 0x42, 0x67, 0x6B, 0x71, 0x68, 0x6B, 0x69, 
	0x47, 0x39, 0x77, 0x30, 0x42, 0x41, 0x51, 0x55, 0x46, 0x41, 0x44, 0x43, 0x42, 0x0D, 0x0A, 0x79, 
	0x6A, 0x45, 0x4C, 0x4D, 0x41, 0x6B, 0x47, 0x41, 0x31, 0x55, 0x45, 0x42, 0x68, 0x4D, 0x43, 0x56, 
	0x56, 0x4D, 0x78, 0x46, 0x7A, 0x41, 0x56, 0x42, 0x67, 0x4E, 0x56, 0x42, 0x41, 0x6F, 0x54, 0x44, 
	0x6C, 0x5A, 0x6C, 0x63, 0x6D, 0x6C, 0x54, 0x61, 0x57, 0x64, 0x75, 0x4C, 0x43, 0x42, 0x4A, 0x62, 
	0x6D, 0x4D, 0x75, 0x4D, 0x52, 0x38, 0x77, 0x48, 0x51, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4C, 0x0D, 
	0x0A, 0x45, 0x78, 0x5A, 0x57, 0x5A, 0x58, 0x4A, 0x70, 0x55, 0x32, 0x6C, 0x6E, 0x62, 0x69, 0x42, 
	0x55, 0x63, 0x6E, 0x56, 0x7A, 0x64, 0x43, 0x42, 0x4F, 0x5A, 0x58, 0x52, 0x33, 0x62, 0x33, 0x4A, 
	0x72, 0x4D, 0x54, 0x6F, 0x77, 0x4F, 0x41, 0x59, 0x44, 0x56, 0x51, 0x51, 0x4C, 0x45, 0x7A, 0x45, 
	0x6F, 0x59, 0x79, 0x6B, 0x67, 0x4D, 0x6A, 0x41, 0x77, 0x4E, 0x69, 0x42, 0x57, 0x5A, 0x58, 0x4A, 
	0x70, 0x0D, 0x0A, 0x55, 0x32, 0x6C, 0x6E, 0x62, 0x69, 0x77, 0x67, 0x53, 0x57, 0x35, 0x6A, 0x4C, 
	0x69, 0x41, 0x74, 0x49, 0x45, 0x5A, 0x76, 0x63, 0x69, 0x42, 0x68, 0x64, 0x58, 0x52, 0x6F, 0x62, 
	0x33, 0x4A, 0x70, 0x65, 0x6D, 0x56, 0x6B, 0x49, 0x48, 0x56, 0x7A, 0x5A, 0x53, 0x42, 0x76, 0x62, 
	0x6D, 0x78, 0x35, 0x4D, 0x55, 0x55, 0x77, 0x51, 0x77, 0x59, 0x44, 0x56, 0x51, 0x51, 0x44, 0x45, 
	0x7A, 0x78, 0x57, 0x0D, 0x0A, 0x5A, 0x58, 0x4A, 0x70, 0x55, 0x32, 0x6C, 0x6E, 0x62, 0x69, 0x42, 
	0x44, 0x62, 0x47, 0x46, 0x7A, 0x63, 0x79, 0x41, 0x7A, 0x49, 0x46, 0x42, 0x31, 0x59, 0x6D, 0x78, 
	0x70, 0x59, 0x79, 0x42, 0x51, 0x63, 0x6D, 0x6C, 0x74, 0x59, 0x58, 0x4A, 0x35, 0x49, 0x45, 0x4E, 
	0x6C, 0x63, 0x6E, 0x52, 0x70, 0x5A, 0x6D, 0x6C, 0x6A, 0x59, 0x58, 0x52, 0x70, 0x62, 0x32, 0x34, 
	0x67, 0x51, 0x58, 0x56, 0x30, 0x0D, 0x0A, 0x61, 0x47, 0x39, 0x79, 0x61, 0x58, 0x52, 0x35, 0x49, 
	0x43, 0x30, 0x67, 0x52, 0x7A, 0x55, 0x77, 0x48, 0x68, 0x63, 0x4E, 0x4D, 0x44, 0x59, 0x78, 0x4D, 
	0x54, 0x41, 0x34, 0x4D, 0x44, 0x41, 0x77, 0x4D, 0x44, 0x41, 0x77, 0x57, 0x68, 0x63, 0x4E, 0x4D, 
	0x7A, 0x59, 0x77, 0x4E, 0x7A, 0x45, 0x32, 0x4D, 0x6A, 0x4D, 0x31, 0x4F, 0x54, 0x55, 0x35, 0x57, 
	0x6A, 0x43, 0x42, 0x79, 0x6A, 0x45, 0x4C, 0x0D, 0x0A, 0x4D, 0x41, 0x6B, 0x47, 0x41, 0x31, 0x55, 
	0x45, 0x42, 0x68, 0x4D, 0x43, 0x56, 0x56, 0x4D, 0x78, 0x46, 0x7A, 0x41, 0x56, 0x42, 0x67, 0x4E, 
	0x56, 0x42, 0x41, 0x6F, 0x54, 0x44, 0x6C, 0x5A, 0x6C, 0x63, 0x6D, 0x6C, 0x54, 0x61, 0x57, 0x64, 
	0x75, 0x4C, 0x43, 0x42, 0x4A, 0x62, 0x6D, 0x4D, 0x75, 0x4D, 0x52, 0x38, 0x77, 0x48, 0x51, 0x59, 
	0x44, 0x56, 0x51, 0x51, 0x4C, 0x45, 0x78, 0x5A, 0x57, 0x0D, 0x0A, 0x5A, 0x58, 0x4A, 0x70, 0x55, 
	0x32, 0x6C, 0x6E, 0x62, 0x69, 0x42, 0x55, 0x63, 0x6E, 0x56, 0x7A, 0x64, 0x43, 0x42, 0x4F, 0x5A, 
	0x58, 0x52, 0x33, 0x62, 0x33, 0x4A, 0x72, 0x4D, 0x54, 0x6F, 0x77, 0x4F, 0x41, 0x59, 0x44, 0x56, 
	0x51, 0x51, 0x4C, 0x45, 0x7A, 0x45, 0x6F, 0x59, 0x79, 0x6B, 0x67, 0x4D, 0x6A, 0x41, 0x77, 0x4E, 
	0x69, 0x42, 0x57, 0x5A, 0x58, 0x4A, 0x70, 0x55, 0x32, 0x6C, 0x6E, 0x0D, 0x0A, 0x62, 0x69, 0x77, 
	0x67, 0x53, 0x57, 0x35, 0x6A, 0x4C, 0x69, 0x41, 0x74, 0x49, 0x45, 0x5A, 0x76, 0x63, 0x69, 0x42, 
	0x68, 0x64, 0x58, 0x52, 0x6F, 0x62, 0x33, 0x4A, 0x70, 0x65, 0x6D, 0x56, 0x6B, 0x49, 0x48, 0x56, 
	0x7A, 0x5A, 0x53, 0x42, 0x76, 0x62, 0x6D, 0x78, 0x35, 0x4D, 0x55, 0x55, 0x77, 0x51, 0x77, 0x59, 
	0x44, 0x56, 0x51, 0x51, 0x44, 0x45, 0x7A, 0x78, 0x57, 0x5A, 0x58, 0x4A, 0x70, 0x0D, 0x0A, 0x55, 
	0x32, 0x6C, 0x6E, 0x62, 0x69, 0x42, 0x44, 0x62, 0x47, 0x46, 0x7A, 0x63, 0x79, 0x41, 0x7A, 0x49, 
	0x46, 0x42, 0x31, 0x59, 0x6D, 0x78, 0x70, 0x59, 0x79, 0x42, 0x51, 0x63, 0x6D, 0x6C, 0x74, 0x59, 
	0x58, 0x4A, 0x35, 0x49, 0x45, 0x4E, 0x6C, 0x63, 0x6E, 0x52, 0x70, 0x5A, 0x6D, 0x6C, 0x6A, 0x59, 
	0x58, 0x52, 0x70, 0x62, 0x32, 0x34, 0x67, 0x51, 0x58, 0x56, 0x30, 0x61, 0x47, 0x39, 0x79, 0x0D, 
	0x0A, 0x61, 0x58, 0x52, 0x35, 0x49, 0x43, 0x30, 0x67, 0x52, 0x7A, 0x55, 0x77, 0x67, 0x67, 0x45, 
	0x69, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 
	0x42, 0x41, 0x51, 0x55, 0x41, 0x41, 0x34, 0x49, 0x42, 0x44, 0x77, 0x41, 0x77, 0x67, 0x67, 0x45, 
	0x4B, 0x41, 0x6F, 0x49, 0x42, 0x41, 0x51, 0x43, 0x76, 0x4A, 0x41, 0x67, 0x49, 0x4B, 0x58, 0x6F, 
	0x31, 0x0D, 0x0A, 0x6E, 0x6D, 0x41, 0x4D, 0x71, 0x75, 0x64, 0x4C, 0x4F, 0x30, 0x37, 0x63, 0x66, 
	0x4C, 0x77, 0x38, 0x52, 0x52, 0x79, 0x37, 0x4B, 0x2B, 0x44, 0x2B, 0x4B, 0x51, 0x4C, 0x35, 0x56, 
	0x77, 0x69, 0x6A, 0x5A, 0x49, 0x55, 0x56, 0x4A, 0x2F, 0x58, 0x78, 0x72, 0x63, 0x67, 0x78, 0x69, 
	0x56, 0x30, 0x69, 0x36, 0x43, 0x71, 0x71, 0x70, 0x6B, 0x4B, 0x7A, 0x6A, 0x2F, 0x69, 0x35, 0x56, 
	0x62, 0x65, 0x78, 0x0D, 0x0A, 0x74, 0x30, 0x75, 0x7A, 0x2F, 0x6F, 0x39, 0x2B, 0x42, 0x31, 0x66, 
	0x73, 0x37, 0x30, 0x50, 0x62, 0x5A, 0x6D, 0x49, 0x56, 0x59, 0x63, 0x39, 0x67, 0x44, 0x61, 0x54, 
	0x59, 0x33, 0x76, 0x6A, 0x67, 0x77, 0x32, 0x49, 0x49, 0x50, 0x56, 0x51, 0x54, 0x36, 0x30, 0x6E, 
	0x4B, 0x57, 0x56, 0x53, 0x46, 0x4A, 0x75, 0x55, 0x72, 0x6A, 0x78, 0x75, 0x66, 0x36, 0x2F, 0x57, 
	0x68, 0x6B, 0x63, 0x49, 0x7A, 0x0D, 0x0A, 0x53, 0x64, 0x68, 0x44, 0x59, 0x32, 0x70, 0x53, 0x53, 
	0x39, 0x4B, 0x50, 0x36, 0x48, 0x42, 0x52, 0x54, 0x64, 0x47, 0x4A, 0x61, 0x58, 0x76, 0x48, 0x63, 
	0x50, 0x61, 0x7A, 0x33, 0x42, 0x4A, 0x30, 0x32, 0x33, 0x74, 0x64, 0x53, 0x31, 0x62, 0x54, 0x6C, 
	0x72, 0x38, 0x56, 0x64, 0x36, 0x47, 0x77, 0x39, 0x4B, 0x49, 0x6C, 0x38, 0x71, 0x38, 0x63, 0x6B, 
	0x6D, 0x63, 0x59, 0x35, 0x66, 0x51, 0x47, 0x0D, 0x0A, 0x42, 0x4F, 0x2B, 0x51, 0x75, 0x65, 0x51, 
	0x41, 0x35, 0x4E, 0x30, 0x36, 0x74, 0x52, 0x6E, 0x2F, 0x41, 0x72, 0x72, 0x30, 0x50, 0x4F, 0x37, 
	0x67, 0x69, 0x2B, 0x73, 0x33, 0x69, 0x2B, 0x7A, 0x30, 0x31, 0x36, 0x7A, 0x79, 0x39, 0x76, 0x41, 
	0x39, 0x72, 0x39, 0x31, 0x31, 0x6B, 0x54, 0x4D, 0x5A, 0x48, 0x52, 0x78, 0x41, 0x79, 0x33, 0x51, 
	0x6B, 0x47, 0x53, 0x47, 0x54, 0x32, 0x52, 0x54, 0x2B, 0x0D, 0x0A, 0x72, 0x43, 0x70, 0x53, 0x78, 
	0x34, 0x2F, 0x56, 0x42, 0x45, 0x6E, 0x6B, 0x6A, 0x57, 0x4E, 0x48, 0x69, 0x44, 0x78, 0x70, 0x67, 
	0x38, 0x76, 0x2B, 0x52, 0x37, 0x30, 0x72, 0x66, 0x6B, 0x2F, 0x46, 0x6C, 0x61, 0x34, 0x4F, 0x6E, 
	0x64, 0x54, 0x52, 0x51, 0x38, 0x42, 0x6E, 0x63, 0x2B, 0x4D, 0x55, 0x43, 0x48, 0x37, 0x6C, 0x50, 
	0x35, 0x39, 0x7A, 0x75, 0x44, 0x4D, 0x4B, 0x7A, 0x31, 0x30, 0x2F, 0x0D, 0x0A, 0x4E, 0x49, 0x65, 
	0x57, 0x69, 0x75, 0x35, 0x54, 0x36, 0x43, 0x55, 0x56, 0x41, 0x67, 0x4D, 0x42, 0x41, 0x41, 0x47, 
	0x6A, 0x67, 0x62, 0x49, 0x77, 0x67, 0x61, 0x38, 0x77, 0x44, 0x77, 0x59, 0x44, 0x56, 0x52, 0x30, 
	0x54, 0x41, 0x51, 0x48, 0x2F, 0x42, 0x41, 0x55, 0x77, 0x41, 0x77, 0x45, 0x42, 0x2F, 0x7A, 0x41, 
	0x4F, 0x42, 0x67, 0x4E, 0x56, 0x48, 0x51, 0x38, 0x42, 0x41, 0x66, 0x38, 0x45, 0x0D, 0x0A, 0x42, 
	0x41, 0x4D, 0x43, 0x41, 0x51, 0x59, 0x77, 0x62, 0x51, 0x59, 0x49, 0x4B, 0x77, 0x59, 0x42, 0x42, 
	0x51, 0x55, 0x48, 0x41, 0x51, 0x77, 0x45, 0x59, 0x54, 0x42, 0x66, 0x6F, 0x56, 0x32, 0x67, 0x57, 
	0x7A, 0x42, 0x5A, 0x4D, 0x46, 0x63, 0x77, 0x56, 0x52, 0x59, 0x4A, 0x61, 0x57, 0x31, 0x68, 0x5A, 
	0x32, 0x55, 0x76, 0x5A, 0x32, 0x6C, 0x6D, 0x4D, 0x43, 0x45, 0x77, 0x48, 0x7A, 0x41, 0x48, 0x0D, 
	0x0A, 0x42, 0x67, 0x55, 0x72, 0x44, 0x67, 0x4D, 0x43, 0x47, 0x67, 0x51, 0x55, 0x6A, 0x2B, 0x58, 
	0x54, 0x47, 0x6F, 0x61, 0x73, 0x6A, 0x59, 0x35, 0x72, 0x77, 0x38, 0x2B, 0x41, 0x61, 0x74, 0x52, 
	0x49, 0x47, 0x43, 0x78, 0x37, 0x47, 0x53, 0x34, 0x77, 0x4A, 0x52, 0x59, 0x6A, 0x61, 0x48, 0x52, 
	0x30, 0x63, 0x44, 0x6F, 0x76, 0x4C, 0x32, 0x78, 0x76, 0x5A, 0x32, 0x38, 0x75, 0x64, 0x6D, 0x56, 
	0x79, 0x0D, 0x0A, 0x61, 0x58, 0x4E, 0x70, 0x5A, 0x32, 0x34, 0x75, 0x59, 0x32, 0x39, 0x74, 0x4C, 
	0x33, 0x5A, 0x7A, 0x62, 0x47, 0x39, 0x6E, 0x62, 0x79, 0x35, 0x6E, 0x61, 0x57, 0x59, 0x77, 0x48, 
	0x51, 0x59, 0x44, 0x56, 0x52, 0x30, 0x4F, 0x42, 0x42, 0x59, 0x45, 0x46, 0x48, 0x2F, 0x54, 0x5A, 
	0x61, 0x66, 0x43, 0x33, 0x65, 0x79, 0x37, 0x38, 0x44, 0x41, 0x4A, 0x38, 0x30, 0x4D, 0x35, 0x2B, 
	0x67, 0x4B, 0x76, 0x0D, 0x0A, 0x4D, 0x7A, 0x45, 0x7A, 0x4D, 0x41, 0x30, 0x47, 0x43, 0x53, 0x71, 
	0x47, 0x53, 0x49, 0x62, 0x33, 0x44, 0x51, 0x45, 0x42, 0x42, 0x51, 0x55, 0x41, 0x41, 0x34, 0x49, 
	0x42, 0x41, 0x51, 0x43, 0x54, 0x4A, 0x45, 0x6F, 0x77, 0x58, 0x32, 0x4C, 0x50, 0x32, 0x42, 0x71, 
	0x59, 0x4C, 0x7A, 0x33, 0x71, 0x33, 0x4A, 0x6B, 0x74, 0x76, 0x58, 0x66, 0x32, 0x70, 0x58, 0x6B, 
	0x69, 0x4F, 0x4F, 0x7A, 0x45, 0x0D, 0x0A, 0x70, 0x36, 0x42, 0x34, 0x45, 0x71, 0x31, 0x69, 0x44, 
	0x6B, 0x56, 0x77, 0x5A, 0x4D, 0x58, 0x6E, 0x6C, 0x32, 0x59, 0x74, 0x6D, 0x41, 0x6C, 0x2B, 0x58, 
	0x36, 0x2F, 0x57, 0x7A, 0x43, 0x68, 0x6C, 0x38, 0x67, 0x47, 0x71, 0x43, 0x42, 0x70, 0x48, 0x33, 
	0x76, 0x6E, 0x35, 0x66, 0x4A, 0x4A, 0x61, 0x43, 0x47, 0x6B, 0x67, 0x44, 0x64, 0x6B, 0x2B, 0x62, 
	0x57, 0x34, 0x38, 0x44, 0x57, 0x37, 0x59, 0x0D, 0x0A, 0x35, 0x67, 0x61, 0x52, 0x51, 0x42, 0x69, 
	0x35, 0x2B, 0x4D, 0x48, 0x74, 0x33, 0x39, 0x74, 0x42, 0x71, 0x75, 0x43, 0x57, 0x49, 0x4D, 0x6E, 
	0x4E, 0x5A, 0x42, 0x55, 0x34, 0x67, 0x63, 0x6D, 0x55, 0x37, 0x71, 0x4B, 0x45, 0x4B, 0x51, 0x73, 
	0x54, 0x62, 0x34, 0x37, 0x62, 0x44, 0x4E, 0x30, 0x6C, 0x41, 0x74, 0x75, 0x6B, 0x69, 0x78, 0x6C, 
	0x45, 0x30, 0x6B, 0x46, 0x36, 0x42, 0x57, 0x6C, 0x4B, 0x0D, 0x0A, 0x57, 0x45, 0x39, 0x67, 0x79, 
	0x6E, 0x36, 0x43, 0x61, 0x67, 0x73, 0x43, 0x71, 0x69, 0x55, 0x58, 0x4F, 0x62, 0x58, 0x62, 0x66, 
	0x2B, 0x65, 0x45, 0x5A, 0x53, 0x71, 0x56, 0x69, 0x72, 0x32, 0x47, 0x33, 0x6C, 0x36, 0x42, 0x46, 
	0x6F, 0x4D, 0x74, 0x45, 0x4D, 0x7A, 0x65, 0x2F, 0x61, 0x69, 0x43, 0x4B, 0x6D, 0x30, 0x6F, 0x48, 
	0x77, 0x30, 0x4C, 0x78, 0x4F, 0x58, 0x6E, 0x47, 0x69, 0x59, 0x5A, 0x0D, 0x0A, 0x34, 0x66, 0x51, 
	0x52, 0x62, 0x78, 0x43, 0x31, 0x6C, 0x66, 0x7A, 0x6E, 0x51, 0x67, 0x55, 0x79, 0x32, 0x38, 0x36, 
	0x64, 0x55, 0x56, 0x34, 0x6F, 0x74, 0x70, 0x36, 0x46, 0x30, 0x31, 0x76, 0x76, 0x70, 0x58, 0x31, 
	0x46, 0x51, 0x48, 0x4B, 0x4F, 0x74, 0x77, 0x35, 0x72, 0x44, 0x67, 0x62, 0x37, 0x4D, 0x7A, 0x56, 
	0x49, 0x63, 0x62, 0x69, 0x64, 0x4A, 0x34, 0x76, 0x45, 0x5A, 0x56, 0x38, 0x4E, 0x0D, 0x0A, 0x68, 
	0x6E, 0x61, 0x63, 0x52, 0x48, 0x72, 0x32, 0x6C, 0x56, 0x7A, 0x32, 0x58, 0x54, 0x49, 0x49, 0x4D, 
	0x36, 0x52, 0x55, 0x74, 0x68, 0x67, 0x2F, 0x61, 0x46, 0x7A, 0x79, 0x51, 0x6B, 0x71, 0x46, 0x4F, 
	0x46, 0x53, 0x44, 0x58, 0x39, 0x48, 0x6F, 0x4C, 0x50, 0x4B, 0x73, 0x45, 0x64, 0x61, 0x6F, 0x37, 
	0x57, 0x4E, 0x71, 0x0D, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x43, 0x45, 
	0x52, 0x54, 0x49, 0x46, 0x49, 0x43, 0x41, 0x54, 0x45, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D
};

//! Temporary ECC key of curve P256 for cipher negotiation with AWS IoT.
const uint8_t AWS_TEMP_DEV_KEY[] = {
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x45, 0x43, 0x20, 0x50, 0x41, 
	0x52, 0x41, 0x4D, 0x45, 0x54, 0x45, 0x52, 0x53, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x42, 0x67, 
	0x67, 0x71, 0x68, 0x6B, 0x6A, 0x4F, 0x50, 0x51, 0x4D, 0x42, 0x42, 0x77, 0x3D, 0x3D, 0x0A, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x45, 0x43, 0x20, 0x50, 0x41, 0x52, 0x41, 0x4D, 
	0x45, 0x54, 0x45, 0x52, 0x53, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x42, 0x45, 0x47, 0x49, 0x4E, 0x20, 0x45, 0x43, 0x20, 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45, 
	0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A, 0x4D, 0x48, 0x63, 0x43, 0x41, 0x51, 
	0x45, 0x45, 0x49, 0x44, 0x43, 0x61, 0x56, 0x39, 0x79, 0x38, 0x6B, 0x52, 0x47, 0x5A, 0x45, 0x75, 
	0x48, 0x6C, 0x4B, 0x44, 0x54, 0x55, 0x37, 0x56, 0x52, 0x35, 0x61, 0x62, 0x46, 0x5A, 0x75, 0x47, 
	0x2F, 0x71, 0x77, 0x38, 0x71, 0x6A, 0x51, 0x62, 0x73, 0x53, 0x61, 0x6C, 0x37, 0x39, 0x6F, 0x41, 
	0x6F, 0x47, 0x43, 0x43, 0x71, 0x47, 0x53, 0x4D, 0x34, 0x39, 0x0A, 0x41, 0x77, 0x45, 0x48, 0x6F, 
	0x55, 0x51, 0x44, 0x51, 0x67, 0x41, 0x45, 0x48, 0x72, 0x39, 0x77, 0x59, 0x6B, 0x6F, 0x69, 0x50, 
	0x45, 0x7A, 0x50, 0x4C, 0x49, 0x62, 0x39, 0x47, 0x30, 0x38, 0x54, 0x62, 0x69, 0x4E, 0x43, 0x55, 
	0x70, 0x75, 0x46, 0x37, 0x47, 0x4A, 0x6B, 0x50, 0x79, 0x56, 0x38, 0x56, 0x71, 0x6E, 0x71, 0x31, 
	0x59, 0x38, 0x58, 0x56, 0x45, 0x5A, 0x5A, 0x77, 0x35, 0x53, 0x61, 0x0A, 0x70, 0x47, 0x6B, 0x72, 
	0x71, 0x49, 0x64, 0x43, 0x65, 0x55, 0x77, 0x2F, 0x7A, 0x70, 0x32, 0x61, 0x49, 0x77, 0x6B, 0x6D, 
	0x6B, 0x54, 0x78, 0x44, 0x6A, 0x57, 0x36, 0x74, 0x50, 0x39, 0x57, 0x73, 0x67, 0x77, 0x3D, 0x3D, 
	0x0A, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x45, 0x4E, 0x44, 0x20, 0x45, 0x43, 0x20, 0x50, 0x52, 0x49, 
	0x56, 0x41, 0x54, 0x45, 0x20, 0x4B, 0x45, 0x59, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x0A
};

/******************************************************************************
* Private function prototypes
******************************************************************************/
int aws_main_build_certificate(t_aws_kit* kit);

/******************************************************************************
* Public function bodies
******************************************************************************/

/**
 * @brief   initialize cryptography module
 * @author  Roberto Andrich
 * @date    2017-10-06
 * @param   
 * @return  
 */

/**
 * @brief   initialize cryptography module
 * @author  Roberto Andrich
 * @date    2017-10-06
 * @param   
 * @return  
 * @modified JRF 07-18-18 
 */
std_return_t crypto_module_init(void)
{
  std_return_t output = E_OK;
  uint8_t atca_status = ATCA_SUCCESS;
  bool lockstate = false;
  uint8_t revision[INFO_SIZE];    
  uint8_t static serial_number[ATCA_SERIAL_NUM_SIZE]; 
    
  do 
  {
    /* Initialize CryptoAuthLib to communicate with ATECC508A over I2C interface. */
    cfg_ateccx08a_i2c_default.atcai2c.slave_address = ATCA_I2C_DEFAULT_ADDRESS;
    atcab_init( &cfg_ateccx08a_i2c_default );  
        
    /* Check for personalization state of configuration & data zone. */
    atca_status = atcab_is_locked(LOCK_ZONE_CONFIG, &lockstate);
    if (atca_status != ATCA_SUCCESS) 
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Failed to read config zone of ATECC508(%d)", ret);
      #endif
      break;
    }
    if (!lockstate)
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Un-Provisioned ATECC508");
      #endif
       break;
    }       
        
    atca_status = atcab_is_locked(LOCK_ZONE_DATA, &lockstate);
    if (atca_status != ATCA_SUCCESS) 
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Failed to read data zone of ATECC508(%d)", ret);
      #endif
      break;
    }
    if (!lockstate)
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Un-Provisioned ATECC508");
      #endif
      break;
    }

    /* Check if CryptoAuthLib works or not. */
    atca_status = atcab_info(revision);
    if (atca_status != ATCA_SUCCESS)
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Failed to initialize ATECC508A!(%d)", ret);
      #endif
      break;
    }

    /* Read serial number of ATECC508A to use it as unique MQTT client ID. */
    atca_status = atcab_read_serial_number(serial_number);
    if (atca_status != ATCA_SUCCESS) 
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Failed to read serial number of ATECC508A!(%d)", ret);
       #endif
       break;
    }
        
    awsKit.user.clientIDLen = (uint32_t)ATCA_SERIAL_NUM_SIZE;

    /* Set a key as parent key to be used for encrypted read, when reading premaster secret. */
    atca_status = atca_tls_init_enc_key();
    if (atca_status != ATCA_SUCCESS) 
    {
      #if CRYPTO_PRINT_DEBUG
        printf("Failed to set parent key!(%d)", ret);
      #endif
      break;
    }
  }while(0);
    
  if (atca_status != ATCA_SUCCESS)
  {
    output = E_NOT_OK;
  }  
  return output;
}

/**
 * @brief   cryptography main function
 * @author  Roberto Andrich
 * @date    2017-10-06
 * @param   
 * @return  
 */
std_return_t crypto_module_main(void)
{
    return E_OK;
}




/**
 * \brief User data verification and loading certificate.
 *
 * Now that user data depending on each of Things is saved in slot8 of ATECC508A,
 * The data can be pull out so that Thing have to connect to WIFI router, and to get destination IP address.
 * Both signer and device certificates should be built in advance to pass them to TLS library.
 *
 * \param kit[inout]        Pointer to an instance of AWS Kit
 * \return AWS_E_SUCCESS    On success
 */
int aws_main_check_kit_state(t_aws_kit* kit)
{
  int ret = AWS_E_FAILURE;
  uint8_t userData[AWS_USER_DATA_OFFSET_MAX];

  do 
  {
    memset(userData, 0x00, sizeof(userData));
    /* Read a bunch of user data from slot8 of ATECC508A. */
    ret = atcab_read_bytes_zone(ATCA_ZONE_DATA, TLS_SLOT8_ENC_STORE, 0x00, userData, sizeof(userData));
    if (ret != ATCA_SUCCESS) 
    {
      #ifdef CRYPTO_PRINT_DEBUG
      printf("Failed to get user data!(%d)", ret);
      #endif
      ret = AWS_E_CRYPTO_FAILURE;
      break;
    }

    /* Set length for each item. */
//    kit->user.ssidLen = AWS_GET_USER_DATA_LEN(userData, AWS_USER_DATA_OFFSET_SSID_LEN);
//    kit->user.pskLen = AWS_GET_USER_DATA_LEN(userData, AWS_USER_DATA_OFFSET_PSK_LEN);
//    kit->user.hostLen = AWS_GET_USER_DATA_LEN(userData, AWS_USER_DATA_OFFSET_HOST_LEN);
//    kit->user.thingLen = AWS_GET_USER_DATA_LEN(userData, AWS_USER_DATA_OFFSET_THING_LEN);

//    /* Check if length is valid. */
//    if (AWS_CHECK_USER_DATA_LEN(kit->user.ssidLen, AWS_WIFI_SSID_MAX) 
////			|| AWS_CHECK_USER_DATA_LEN(kit->user.pskLen, AWS_WIFI_PSK_MAX)
//			|| AWS_CHECK_USER_DATA_LEN(kit->user.hostLen, AWS_HOST_ADDR_MAX)
//	//		|| AWS_CHECK_USER_DATA_LEN(kit->user.thingLen, AWS_THING_NAME_MAX)
////			|| AWS_CHECK_USER_DATA(userData, AWS_USER_DATA_OFFSET_SSID)
////			|| AWS_CHECK_USER_DATA(userData, AWS_USER_DATA_OFFSET_PSK)
////			|| AWS_CHECK_USER_DATA(userData, AWS_USER_DATA_OFFSET_HOST)
//	//		|| AWS_CHECK_USER_DATA(userData, AWS_USER_DATA_OFFSET_THING)
//	) 
//    {
//      ret = AWS_E_USER_DATA_INVALID;
//      #ifdef CRYPTO_PRINT_DEBUG
//      printf("Invalid user data, try to setup again!(%d)", ret);
//      #endif
//      break;
//    }

    /* Copy each of items to corresponding variables. */
//    memcpy(kit->user.ssid, &userData[AWS_USER_DATA_OFFSET_SSID], kit->user.ssidLen);
//    memcpy(kit->user.psk, &userData[AWS_USER_DATA_OFFSET_PSK], kit->user.pskLen);
//    memcpy(kit->user.host, &userData[AWS_USER_DATA_OFFSET_HOST], kit->user.hostLen);
//    //memcpy(kit->user.thing, "STMICRO", sizeof("STMICRO"));
    memcpy(kit->user.thing, "testes", sizeof("testes"));
    
    sprintf((char*)kit->user.host,"%s"  , "a9k7ikyv1zic9.iot.us-east-1.amazonaws.com");
    //sprintf((char*)kit->user.host,"%s"  , "a9k7ikyv1zic9.iot.eu-central-1.amazonaws.com");
    
//    /* Set button state with previously saved state to keep it. */
//    for (uint8_t i = 0; i < AWS_KIT_BUTTON_MAX; i++) 
//    {
//      if (userData[AWS_USER_DATA_BUTTON_STATE + i] == true)
//        kit->button.state[i] = true;
//      else
//        kit->button.state[i] = false;
//    }
    /* Build signer & device certificates to be set for TLS library. */
    ret = aws_main_build_certificate(kit);
    if (ret != AWS_E_SUCCESS) break;
    #ifdef CRYPTO_PRINT_DEBUG
    printf("SSID : %s, PWD : %s", kit->user.ssid, kit->user.psk);
    printf("HOST : %s, THING : %s", kit->user.host, kit->user.thing);
    #endif
    
  } while(0);
  return ret;
}




/**
 * @brief   cryptography main function
 * @author  JRF 
 * @date    2018-03-12
 * @param   
 * @return  
 */
void crypto_main_state_machine (void)
{
  int ret = AWS_E_SUCCESS;
  static uint8_t currState = MAIN_STATE_INIT_KIT;
  static uint8_t nextState = MAIN_STATE_INVALID;
  //static t_aws_kit* kit;
//jrf???
//  switch (currState)
//  {
//    case MAIN_STATE_INIT_KIT:       
//      ret = crypto_module_init();
//      if (ret == E_NOT_OK) 
//      {
//        //kit->errState = AWS_EX_UNPROVISIONED_CRYPTO;
//        //aws_user_exception_init_timer(kit);
//        nextState = MAIN_STATE_PROVISIONING;
//      }
//      else
//      {
//        /* The kit has been initialized without any problem, go to next state */
//	nextState = MAIN_STATE_CHECK_KIT;
//      }
//      break;
//
//      case MAIN_STATE_CHECK_KIT:
//        /* Check if all WIFI credential, AWS IoT host address and Thing name are available, 
//	   and build signer & device certificates. */
//        ret = aws_main_check_kit_state(&awsKit);
//        if (ret != AWS_E_SUCCESS) 
//        {
//          nextState = MAIN_STATE_PROVISIONING;
//        }
//        else
//        {
//          //kit->errState = AWS_EX_NONE;
//	  nextState = MAIN_STATE_RUN_KIT;
//	  //kit->quitMQTT = false;
//	  /* Resume Client task, if kit has been provisioned by using Insight GUI without any invalid configuration. */
//	  //vTaskResume(clientTaskHandler);
//	}
//	break;
//
//	case MAIN_STATE_PROVISIONING:
//          //JRF error ATECC508A is not provisioned To Be Implemented
//          while(1);
//	  break;
//
//	  case MAIN_STATE_RUN_KIT:
//            /* Wait for a notification again to support multiple provisioning. */
//	    //ret = aws_main_wait_notification(kit);
//            if (ret == AWS_E_MQTT_REINITIALIZE) 
//            {
//              nextState = MAIN_STATE_PROVISIONING;
//            }
//            else
//            {
//              nextState = MAIN_STATE_RUN_KIT;
//            }
//	    break;
//
//          case MAIN_STATE_INVALID:
////            AWS_ERROR("Invalid main state");
////            nextState = MAIN_STATE_INVALID;
//	    break;
//
//	  default:
//            break;
//  }
  //currState = kit->mainState = nextState;
  currState = nextState;
}

/**
 * \brief Build certificates.
 *
 * Now that both signer and device certificate was saved onto specified slot with certificate definition,
 * Both certificates can be built based on certificate definition in order to pass them to TLS library.
 *
 * \param kit[inout]        Pointer to an instance of AWS Kit
 * \return AWS_E_SUCCESS    On success
 */
int aws_main_build_certificate(t_aws_kit* kit)
{
	int ret = AWS_E_FAILURE;
	t_atcert cert;

	/* Allocate heap to obtain signer DER, PEM certificates and public key space. */
	cert.signer_der = (uint8_t*)malloc(DER_CERT_INIT_SIZE);
	if (cert.signer_der == NULL) goto free_cert;
	cert.signer_der_size = DER_CERT_INIT_SIZE;
	cert.signer_pem = (uint8_t*)malloc(PEM_CERT_INIT_SIZE);
	if (cert.signer_pem == NULL) goto free_cert;
	cert.signer_pem_size = PEM_CERT_INIT_SIZE;
	cert.signer_pubkey= (uint8_t*)malloc(ATCERT_PUBKEY_SIZE);
	if (cert.signer_pubkey == NULL) goto free_cert;

	/* Build signer certificate */
	ret = atca_tls_build_signer_cert(&cert);
	if (ret != ATCA_SUCCESS) {
		ret = AWS_E_CRYPTO_CERT_FAILURE;
		printf("Failed to build signer certificate!(%d)", ret);
		goto free_cert; 
	}

	/* Allocate heap to secure device DER, PEM certificates and public key space. */
	cert.device_der = (uint8_t*)malloc(DER_CERT_INIT_SIZE);
	if (cert.device_der == NULL) goto free_cert;
	cert.device_der_size = DER_CERT_INIT_SIZE;
	cert.device_pem = (uint8_t*)malloc(PEM_CERT_INIT_SIZE);
	if (cert.device_pem == NULL) goto free_cert;
	cert.device_pem_size = PEM_CERT_INIT_SIZE;
	cert.device_pubkey= (uint8_t*)malloc(ATCERT_PUBKEY_SIZE);
	if (cert.device_pubkey == NULL) goto free_cert;

	/* Build device certificate. */
	ret = atca_tls_build_device_cert(&cert);
	if (ret != ATCA_SUCCESS) {
		ret = AWS_E_CRYPTO_CERT_FAILURE;
		printf("Failed to build device certificate!(%d)", ret);
		goto free_cert; 
	}

	/* Copy both PEM certificates to corresponding fields to be used for TLS library. */
	kit->cert.signerCertLen = cert.signer_pem_size;
	memcpy(kit->cert.signerCert, cert.signer_pem, kit->cert.signerCertLen);
	kit->cert.devCertLen = cert.device_pem_size;
	memcpy(kit->cert.devCert, cert.device_pem, kit->cert.devCertLen);

	/* Release temporary heap region */
free_cert:
	if (cert.signer_der) free(cert.signer_der);
	if (cert.signer_pem) free(cert.signer_pem);
	if (cert.signer_pubkey) free(cert.signer_pubkey);
	if (cert.device_der) free(cert.device_der);
	if (cert.device_pem) free(cert.device_pem);
	if (cert.device_pubkey) free(cert.device_pubkey);

	return ret;
}

/**
 * \brief AWS IoT authenticates Things using X.509 certificates.
 * In addition to it, all traffic to and from AWS IoT MUST be encrypted over Transport Layer Security(TLS).
 * So the WolfSSL library is responsible for the TLS layer.
 *
 * \param kit[in]             Pointer to an instance of AWS Kit
 * \return AWS_E_SUCCESS      On success
 */
int aws_client_net_tls_cb(t_aws_kit* kit)
{
	int ret = AWS_E_SUCCESS;
	uint8_t* cert_chain = NULL;

	do {

#ifdef AWS_KIT_DEBUG
		wolfSSL_Debugging_ON();
#else
		wolfSSL_Debugging_OFF();
		HAL_Delay(500); 
#endif
		/* Initialize SSL context. */
		kit->tls.context = wolfSSL_CTX_new(wolfTLSv1_2_client_method());
		if (kit->tls.context == NULL) {
			printf("Failed to init context!");
			break;
		}

		/* ATECC508A supports ECC(ECDH, ECDSA) hardware acceleration. 
		   ECDHE-ECDSA-AES128-GCM-SHA256 cipher suite recommends by AWS IoT is set for authentication and data encryption. */
		ret = wolfSSL_CTX_set_cipher_list(kit->tls.context, AWS_IOT_CIPHER_SPEC);
		if (ret != SSL_SUCCESS) {
			printf("Failed to set cipher!");
			break;
		}

		/* Since AWS IoT server was signed by the VeriSign root CA, this root CA certificate should be loaded to WolfSSL to verify AWS ioT. */
		ret = wolfSSL_CTX_load_verify_buffer(kit->tls.context, AWS_IOT_ROOT_CERT, sizeof(AWS_IOT_ROOT_CERT), SSL_FILETYPE_PEM);
		if (ret != SSL_SUCCESS) {
			printf("Failed to set root cert!");
			break;
		}

		/* As the AT88CKECCSIGNER already signed ATECC508A of Thing, There are the Signer and Device certificates in the ATECC508A. 
		Both certificates should be set to WolfSSL for the JITR achievement. */
		cert_chain = (uint8_t*)malloc(kit->cert.signerCertLen + kit->cert.devCertLen);
		memcpy(&cert_chain[0], kit->cert.devCert, kit->cert.devCertLen);
		memcpy(&cert_chain[kit->cert.devCertLen], kit->cert.signerCert, kit->cert.signerCertLen);
		ret = wolfSSL_CTX_use_certificate_chain_buffer(kit->tls.context, cert_chain, kit->cert.signerCertLen + kit->cert.devCertLen);
		if (ret != SSL_SUCCESS) {
			printf("Failed to set cert chain!");
			break;
		}

		/* This Device private key is not actual private key of ATECC508A, and WolfSSL never use it as own Device key. 
		   This temporary key has been set to make sure Device owns a private key. */
		ret = wolfSSL_CTX_use_PrivateKey_buffer(kit->tls.context, AWS_TEMP_DEV_KEY, sizeof(AWS_TEMP_DEV_KEY), SSL_FILETYPE_PEM);
		if (ret != SSL_SUCCESS) {
			printf("Failed to set fake key!");
			break;
		}

		/* Turn on a certificate request from the server to the client. */
		wolfSSL_CTX_set_verify(kit->tls.context, SSL_VERIFY_PEER, NULL);
		/* Set the Public key Callback for ECC Signing. */
		wolfSSL_CTX_SetEccSignCb(kit->tls.context, atca_tls_sign_certificate_cb);
		/* Set the Public key Callback for ECC Verification. */
		wolfSSL_CTX_SetEccVerifyCb(kit->tls.context, atca_tls_verify_signature_cb);
		/* Set the Public key Callback for Pre-Master Secret creation. */
		wolfSSL_CTX_SetEccPmsCb(kit->tls.context, atca_tls_create_pms_cb);

	} while(0);

	if (cert_chain)
		free(cert_chain);

	return ret;
}

//int aws_client_tls_receive(WOLFSSL* ssl, char *buf, int sz, void *ptr)
//{
//	int ret;
//	MQTTClient* client = (MQTTClient*)ptr;
////	t_aws_kit* kit = aws_kit_get_instance();
////
////	ret = network_socket_read(kit->socket, (unsigned char*)buf, sz, kit->tls.ssl->rflags, client->command_timeout_ms);	
//
//        //if ( (status = modem_socket_client_write(my_socket, bytestowrite, (char *)writebuffer)) == MODEM_MODULE_SUCCESS)
//        
//          
//	if (ret == SUCCESS)
//		ret = WOLFSSL_CBIO_ERR_WANT_READ;
//	else if (ret < 0)
//		ret = WOLFSSL_CBIO_ERR_GENERAL;
//		
//	return ret;
//}

//int aws_client_tls_send(WOLFSSL* ssl, char *buf, int sz, void *ptr)
//{
//  int ret;
////	MQTTClient* client = (MQTTClient*)ptr;
////	t_aws_kit* kit = aws_kit_get_instance();
////	
////	ret = network_socket_write(kit->socket, (unsigned char*)buf, sz, kit->tls.ssl->wflags, client->command_timeout_ms);
////  ret = modem_socket_client_write(kit->socket, bytestowrite, (char *)writebuffer); //) == MODEM_MODULE_SUCCESS)
//
//  //Modem_Status_t modem_socket_client_write(uint8_t sock_id, uint16_t DataLength, char * pData)
//  
////  if (ret == 0)
////        ret = WOLFSSL_CBIO_ERR_WANT_WRITE;
////  else if (ret < 0)
////        ret = WOLFSSL_CBIO_ERR_GENERAL;
//	
//  return ret;
//}

/******************************************************************************
* Private function bodies
******************************************************************************/
 


/** @} */
